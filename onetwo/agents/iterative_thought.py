# Copyright 2024 DeepMind Technologies Limited.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Implementation of an "iterative thought" strategy using the Agent framework.

What we refer to here as "iterative thought" is a simple strategy where an LLM
is called iteratively, being prompted in each step to output another "thought"
until one of the thoughts achieves a solution to the original problem. It is
similar to "chain of thought" (https://arxiv.org/pdf/2201.11903.pdf), except
that it results in an explicit sequence of thoughts (each as a separate string),
rather than a single block of text that implicitly contains some sequence of
thoughts.

The advantage of using an IterativeThoughtAgent rather than chain-of-thought is
that the IterativeThoughtAgent can be easily composed with other agent
strategies like BeamSearch, which corresponds to the approach taken for
solving the Game of 24 problem in the Tree-of-Thoughts paper
(https://arxiv.org/pdf/2305.10601.pdf). The disadvantage of using
IterativeThoughtAgent is that it typically involves more LLM calls than
chain-of-thought to achieve the same effect.
"""

import abc
import dataclasses
from typing import Protocol

from onetwo.agents import agents_base
from onetwo.builtins import prompt_templating
from onetwo.core import executing
from onetwo.core import tracing


# In an iterative thought strategy, the state consists of the original question
# paired with a monotonically increasing sequence of steps, each of which
# represents a "thought" that was generated by the LLM.
IterativeThoughtState = agents_base.UpdateListState[str, str]


# Recommended LLM sampling settings: `temperature=0.7`.
ITERATIVE_THOUGHT_PROMPT = """\
{#- Preamble: Problem description -#}
{{ description + '\n' }}

{#- Preamble: Few-shots exemplars -#}
{%- for exemplar in few_shots -%}
{%-for i in range(exemplar.updates|length) -%}
Input: {{ exemplar.inputs + '\n' }}
{%- for step in exemplar.updates[:i+1] -%}
Step #{{ loop.index }}: {{ step + '\n' }}
{%- endfor -%}
{%- endfor -%}
{%- endfor -%}

{#- Start of the processing of the actual inputs. -#}
Input: {{ state.inputs + '\n' }}
{%- for step in state.updates -%}
Step #{{ loop.index }}: {{ step + '\n' }}
{%- endfor -%}
Step #{{ state.updates|length + 1 }}:\
{{ store('next_step', generate_text(stop=['Input', 'Step #', '\\n\\n', '[eod]']) | trim) }}
"""


class IterativeThoughtPromptProtocol(Protocol):
  """Interface for prompt usable with IterativeThoughtAgent.prompt."""

  @executing.make_executable
  @abc.abstractmethod
  async def __call__(
      self,
      description: str,
      few_shots: list[IterativeThoughtState],
      state: IterativeThoughtState,
  ) -> str:
    """Executes the prompt template on the given args and returns the result.

    Args:
      description: Description of the problem to solve (in general, not a
        particular instance).
      few_shots: Few-shot exemplars that can be used in the prompt.
      state: Current state of the iterative thought strategy, i.e., the sequence
        of steps (if any) that have been performed so far.

    Returns:
      The next step (i.e., the next "thought") for solving the problem.
      The agent is expected to append this to the `state` in the next round.
    """


@dataclasses.dataclass
class IterativeThoughtPromptJ2(
    IterativeThoughtPromptProtocol, prompt_templating.JinjaTemplateWithCallbacks
):
  """JinjaTemplate usable with IterativeThoughtAgent.prompt.

  Attributes:
    text: Text of the prompt template.
  """

  # Overriding default value of attribute defined in templating.JinjaTemplate.
  text: str = ITERATIVE_THOUGHT_PROMPT

  @executing.make_executable
  async def __call__(
      self,
      description: str,
      few_shots: list[IterativeThoughtState],
      state: IterativeThoughtState,
  ) -> str:
    """Executes the prompt template on the given args and returns the result.

    Args:
      description: Description of the problem to solve (in general, not a
        particular instance).
      few_shots: Few-shot exemplars that can be used in the prompt.
      state: Current state of the iterative thought strategy, i.e., the sequence
        of steps (if any) that have been performed so far.

    Returns:
      The next step (i.e., the next "thought") for solving the problem.
      The agent is expected to append this to the `state` in the next round.
    """
    result = await self.render(
        description=description, few_shots=few_shots, state=state
    )
    return result['next_step']


@dataclasses.dataclass
class IterativeThoughtAgent(
    agents_base.SingleSampleAgent[
        str, list[str], IterativeThoughtState, str, None
    ]
):
  """Agent that solves a problem through iterative prompting of the LLM.

  Returns as final output the full list of thoughts that were generated (i.e.,
  the trajectory taken to reach the solution).

  Attributes:
    description: Description of the problem.
    prompt: Jinja2-style prompt template used for prompting the LLM to execute a
      single step.
    few_shots: Few-shot examples to include in the prompt.
  """

  description: str = ''
  prompt: IterativeThoughtPromptProtocol = dataclasses.field(
      default_factory=IterativeThoughtPromptJ2
  )
  few_shots: list[IterativeThoughtState] = dataclasses.field(
      default_factory=list
  )

  @executing.make_executable(copy_self=False)
  async def initialize_state(self, inputs: str) -> IterativeThoughtState:
    """Returns a newly initialized state based on the input question.

    Overridden from base class (Agent).

    Args:
      inputs: Input to the agent, representing the overall goal that the agent
        is trying to achieve.
    """
    return IterativeThoughtState(inputs=inputs)

  def extract_output(self, state: IterativeThoughtState) -> list[str]:
    """Returns as final output the full list of thoughts that was generated.

    Overridden from base class (Agent).

    Args:
      state: Current (presumably final) state of the agent.
    """
    return state.updates

  @executing.make_executable(copy_self=False, non_copied_args=['environment'])
  @tracing.trace(
      'IterativeThoughtAgent._sample_single_next_step', skip=['environment']
  )
  async def _sample_single_next_step(
      self, state: IterativeThoughtState, environment: None = None
  ) -> str:
    """Samples one possible next step of the agent strategy.

    Overridden from base class (SingleSampleAgent).

    Args:
      state: Current state of the agent.
      environment: Environment in which to perform the operation. Not relevant
        for IterativeThought.

    Returns:
      An incremental update to the agent state that would occur as a result of
      performing the given step.
    """
    # Prompt the LLM to generate the next thought.
    return await self.prompt(
        description=self.description,
        few_shots=self.few_shots,
        state=state,
    )


@dataclasses.dataclass
class IterativeThoughtProposerExemplar:
  """Exemplar for use in the prompt of an IterativeThoughtProposerAgent.

  Attributes:
    state: The state of the agent prior to prompting the LLM.
    next_steps: Proposed next steps that were output by the LLM.
  """
  state: IterativeThoughtState = dataclasses.field(
      default_factory=IterativeThoughtState
  )
  next_steps: list[str] = dataclasses.field(default_factory=list)


# Recommended LLM sampling settings: `temperature=0.1`.
ITERATIVE_THOUGHT_PROPOSER_PROMPT = """\
{#- Preamble: Problem description -#}
{{ description }}

{#- Preamble: Few-shots exemplars -#}
{%- for exemplar in few_shots %}
Input: {{ exemplar.state.inputs + '\n' }}
{%- for step in exemplar.state.updates -%}
Step #{{ loop.index }}: {{ step + '\n' }}
{%- endfor -%}
The next step could be one of the following (one per row):
{% for step in exemplar.next_steps -%}
{{ step + '\n' }}
{%- endfor -%}
{%- endfor -%}

{#- Start of the processing of the actual inputs. #}
Input: {{ state.inputs + '\n' }}
{%- for step in state.updates -%}
Step #{{ loop.index }}: {{ step + '\n' }}
{%- endfor -%}
The next step could be one of the following (one per row):
{{ store('next_steps', generate_text(stop=['Input', '\\n\\n', '[eod]']).split('\\n')) }}
"""


class IterativeThoughtProposerPromptProtocol(Protocol):
  """Interface for prompt usable with IterativeThoughtProposerAgent.prompt."""

  @executing.make_executable
  @abc.abstractmethod
  async def __call__(
      self,
      description: str,
      few_shots: list[IterativeThoughtProposerExemplar],
      state: IterativeThoughtState,
  ) -> list[str]:
    """Executes the prompt template on the given args and returns the result.

    Args:
      description: Description of the problem to solve (in general, not a
        particular instance).
      few_shots: Few-shot exemplars that can be used in the prompt.
      state: Current state of the iterative thought strategy, i.e., the sequence
        of steps (if any) that have been performed so far.

    Returns:
      Candidate next steps (i.e., candidates for the next "thought") for solving
      the problem. The agent is expected to append one of these to the `state`
      in the next round.
    """


@dataclasses.dataclass
class IterativeThoughtProposerPromptJ2(
    IterativeThoughtProposerPromptProtocol,
    prompt_templating.JinjaTemplateWithCallbacks,
):
  """JinjaTemplate usable with IterativeThoughtProposerAgent.prompt.

  Attributes:
    text: Text of the prompt template.
  """

  # Overriding default value of attribute defined in templating.JinjaTemplate.
  text: str = ITERATIVE_THOUGHT_PROPOSER_PROMPT

  @executing.make_executable
  async def __call__(
      self,
      description: str,
      few_shots: list[IterativeThoughtProposerExemplar],
      state: IterativeThoughtState,
  ) -> list[str]:
    """Executes the prompt template on the given args and returns the result.

    Args:
      description: Description of the problem to solve (in general, not a
        particular instance).
      few_shots: Few-shot exemplars that can be used in the prompt.
      state: Current state of the iterative thought strategy, i.e., the sequence
        of steps (if any) that have been performed so far.

    Returns:
      Candidate next steps (i.e., candidates for the next "thought") for solving
      the problem. The agent is expected to append one of these to the `state`
      in the next round.
    """
    result = await self.render(
        description=description, few_shots=few_shots, state=state
    )
    return result['next_steps']


@dataclasses.dataclass
class IterativeThoughtProposerAgent(
    agents_base.Agent[str, list[str], IterativeThoughtState, str, None]
):
  """IterativeThought agent variant that prompts LLM to propose multiple steps.

  Returns as final output the full list of thoughts that were generated (i.e.,
  the trajectory taken to reach the solution).

  Attributes:
    description: Description of the problem.
    prompt: Jinja2-style prompt template used for prompting the LLM to propose
      multiple candidate next steps.
    few_shots: Few-shot examples to include in the prompt.
  """

  description: str = ''
  prompt: IterativeThoughtProposerPromptProtocol = dataclasses.field(
      default_factory=IterativeThoughtProposerPromptJ2
  )
  few_shots: list[IterativeThoughtProposerExemplar] = dataclasses.field(
      default_factory=list
  )

  @executing.make_executable(copy_self=False)
  async def initialize_state(self, inputs: str) -> IterativeThoughtState:
    """Returns a newly initialized state based on the input question.

    Overridden from base class (Agent).

    Args:
      inputs: Input to the agent, representing the overall goal that the agent
        is trying to achieve.
    """
    return IterativeThoughtState(inputs=inputs)

  def extract_output(self, state: IterativeThoughtState) -> list[str]:
    """Returns as final output the full list of thoughts that was generated.

    Overridden from base class (Agent).

    Args:
      state: Current (presumably final) state of the agent.
    """
    return state.updates

  @executing.make_executable(copy_self=False, non_copied_args=['environment'])
  @tracing.trace(
      'IterativeThoughtProposerAgent.sample_next_step', skip=['environment']
  )
  async def sample_next_step(
      self,
      state: IterativeThoughtState,
      num_candidates: int,
      environment: None = None,
  ) -> list[str]:
    """Samples up to `num_candidates` possible next steps of the agent strategy.

    Overridden from base class (Agent).

    Args:
      state: Current state of the agent.
      num_candidates: Number of possible next steps to generate. May return
        fewer than the requested number of candidates, however, depending on the
        LLM reply.
      environment: Environment in which to perform the operation. Not relevant
        for IterativeThought.

    Returns:
      An incremental update to the agent state that would occur as a result of
      performing each of the possible next steps.
    """
    # Prompt the LLM to generate a list of possible next thoughts.
    next_steps = await self.prompt(
        description=self.description,
        few_shots=self.few_shots,
        state=state,
    )
    return next_steps[:num_candidates]
